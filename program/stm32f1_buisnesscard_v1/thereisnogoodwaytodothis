#include <stdint.h>
#include <string.h>
#include "mandelbrot.h"
#include "st7735.h"
#include "benchmark.h"
#include "main.h"

#define RES_X             160
#define RES_Y             80
#define DEFAULT_CENTER_X  0
#define DEFAULT_CENTER_Y  0
#define STEP_SIZE         .1
#define ZOOM_SIZE         .1

#define DECIMAL_LOC           28
#define DOUBLE_SCALER         (1 << DECIMAL_LOC)
#define DOUBLE_TO_FIXED(val)  (int32_t)((val) * DOUBLE_SCALER)
#define FIXED_MULTIPLY(x,y)   ((((uint64_t)(x))*(y)) >> DECIMAL_LOC)
#define FIXED_TO_DOUBLE(val)  ((val) / (double)DOUBLE_SCALER)

#define INFTY     2
#define INFTY_SQR INFTY * INFTY
#define ITERS     255
#define INFTY_SQR_FIXED DOUBLE_TO_FIXED(INFTY_SQR)

//TODO move to some hardware.h or somethin
//channel order: B, G, R
#define R_BITS  5
#define G_BITS  6
#define B_BITS  5

//imaginary axis set automatically
#define CAM_DEF_MIN_R -1
#define CAM_DEF_MAX_R  1

//set controls 
#define CAM_MOVE_UP     BUTTON_UP     
#define CAM_MOVE_RIGHT  BUTTON_RIGHT
#define CAM_MOVE_DOWN   BUTTON_DOWN   
#define CAM_MOVE_LEFT   BUTTON_LEFT   
#define CAM_ZOOM_IN     BUTTON_A      
#define CAM_ZOOM_OUT    BUTTON_B      

struct camera {
  double min_r, min_i, max_r, max_i;
};

enum VIEW_MODES { VIEW_UNINIT, VIEW_MANDREL, VIEW_SHIP };

void init_colorscheme_mandrel(uint16_t *scheme) {
  uint16_t *tc = scheme;
  for(unsigned int i = 0; i < ITERS; i++) {
    if((i == 0) || (i == ITERS)) *tc = 0;
    else if(i < 128) *tc = (((((i - 64) << 2)+0x1f) & 0x1f) | (((((i - 128) << 1)+0x1f) & 0x1f) << (5+6)));
    else *tc = (-2*(i - 128)+0x1f) & 0xff;
    *tc = (*tc << 8) | (*tc >> 8); //convert to little endian
    tc++;
  }
}

void init_colorscheme_ship(uint16_t *scheme) {
  uint16_t *tc = scheme;
  for(unsigned int i = 0; i < ITERS; i++) {
    if((i == 0) || (i == ITERS)) *tc = 0;
    else *tc = (((i - (128)) << 1)+0x1f) << (5+6);
    tc++;
  }
}

void cam_shift(struct camera *cam, double step_r, double step_i) {
  double i_offset = (cam->max_i - cam->min_i) * step_i;
  double r_offset = (cam->max_r - cam->min_r) * step_r;
  cam->min_i += i_offset;
  cam->max_i += i_offset;
  cam->min_r += r_offset;
  cam->max_r += r_offset;
}

void cam_zoom(struct camera *cam, double zoom) {
  double i_scale = (cam->max_i - cam->min_i) * zoom;
  double r_scale = (cam->max_r - cam->min_r) * zoom;
  cam->min_i += i_scale;
  cam->max_i -= i_scale;
  cam->min_r += r_scale;
  cam->max_r -= r_scale;
}


//TODO look into border tracing; this is too slow. Change name
//
void render_mandelbrot(uint16_t *framebuffer, uint16_t *colorscheme, struct camera cam, int x0, int y0, int w, int h) {
  int32_t scale_i = DOUBLE_TO_FIXED((cam.max_i - cam.min_i) / (double)RES_Y);
  int32_t scale_r = DOUBLE_TO_FIXED((cam.max_r - cam.min_r) / (double)RES_X);
  int32_t c_i = DOUBLE_TO_FIXED((((cam.max_i - cam.min_i) * (RES_Y - y0)) / RES_Y) + cam.min_i);
  int32_t c_r0 = DOUBLE_TO_FIXED((((cam.max_r - cam.min_r) * x0) / RES_X) + cam.min_r);
  int32_t c_r, z_i, z_r, zn_r, z_r_2, z_i_2;
  size_t fb_index = 0;
  int i; 
  
  //for(;;);

  for(int y = y0; y < y0 + h; y++) {
    c_r = c_r0;
    for(int x = x0; x < x0 + w; x++) {
      z_i = 0;
      z_r = 0;
      for(i = 0; i < ITERS; i++) {
        z_r_2 = FIXED_MULTIPLY(z_r, z_r);
        z_i_2 = FIXED_MULTIPLY(z_i, z_i);

        zn_r = z_r_2 - z_i_2 + c_r;

        //z_i = abs(FIXED_MULTIPLY((DOUBLE_TO_FIXED(2)), (FIXED_MULTIPLY(z_r, z_i)))) + c_i;
        z_i = (FIXED_MULTIPLY(z_r, z_i) << 1)  + c_i;

        z_r = zn_r;

        if(z_i_2 + z_r_2 > INFTY_SQR_FIXED) break;
      }
      framebuffer[fb_index++] = colorscheme[i];
      c_r += scale_r;
    }
    c_i -= scale_i;
  }
}
  


#define FB_SIZE_X RES_X
#define FB_SIZE_Y RES_Y/2

//TODO rename
void draw_mandelbrot(int key_pressed) {
  static uint16_t framebuffer[FB_SIZE_X * FB_SIZE_Y];
  uint16_t columnbuffer[8*RES_Y];
  static bool bottom_buffered = true;
  //program flow is awful atm becuase I was planning something different; will be improved soon.
  static struct camera cam = {
    .min_r = CAM_DEF_MIN_R,
    .max_r = CAM_DEF_MAX_R,
    .min_i = ((double)RES_Y / RES_X) * CAM_DEF_MIN_R,
    .max_i = ((double)RES_Y / RES_X) * CAM_DEF_MAX_R,

  };
  static int view_mode = VIEW_UNINIT;
  static uint16_t colorscheme[ITERS];


  
  //we could get rid of this and do some awful bitbashing lol
  //but for readability, we shant
  //TODO camera moves l/r more then u/d for some reason
  /**
  if(key_pressed & CAM_MOVE_UP)    cam_shift(&cam, 0, STEP_SIZE);
  if(key_pressed & CAM_MOVE_DOWN)  cam_shift(&cam, 0, -STEP_SIZE);
  if(key_pressed & CAM_MOVE_RIGHT) cam_shift(&cam, -STEP_SIZE, 0);
  if(key_pressed & CAM_MOVE_LEFT)  cam_shift(&cam, STEP_SIZE, 0);
  if(key_pressed & CAM_ZOOM_IN)    cam_zoom(&cam, ZOOM_SIZE);
  if(key_pressed & CAM_ZOOM_OUT)   cam_zoom(&cam, -ZOOM_SIZE);
  **/
  
  //yes, I know the following is disgusting. Before I clean it, I just wanna get the general idea out, 
  //it's more efficient in that order
  //TODO once you  get your idea ironed out, clean the code and improve the flow
  benchmark_start();
  if(view_mode == VIEW_UNINIT) {
    view_mode = VIEW_MANDREL;
    init_colorscheme_mandrel(colorscheme);
    render_mandelbrot(framebuffer, colorscheme, cam, 0, 0, RES_X, RES_Y/2);
    ST7735_DrawImage(0, 0, RES_X, (RES_Y / 2), framebuffer);
    render_mandelbrot(framebuffer, colorscheme, cam, 0, RES_Y/2, RES_X, RES_Y/2);
    ST7735_DrawImage(0, (RES_Y / 2), RES_X, (RES_Y / 2), framebuffer);
    bottom_buffered = true;
  }
  else {
    uint16_t top_line = bottom_buffered ? (RES_Y/2) : 0; 
    switch(key_pressed) {
      const int y_offset = STEP_SIZE * RES_Y;
      const int x_offset = STEP_SIZE * RES_X;
      const size_t lines_rendered = (RES_Y/2) - y_offset;
      const size_t rendered_area_y = RES_X * lines_rendered * sizeof(uint16_t);
      const uint16_t framebuffer_offset_y = framebuffer + (RES_X * y_offset);
      const uint16_t columns_rendered = RES_X - x_offset;
      const uint16_t 
      case BUTTON_UP:
        cam_shift(&cam, 0, STEP_SIZE);
        memmove(framebuffer_offset, framebuffer, rendered_area_y);
        render_mandelbrot(framebuffer, colorscheme, cam, 0, top_line, RES_X, y_offset);
        break;
      case BUTTON_DOWN:
        cam_shift(&cam, 0, -STEP_SIZE);
        memmove(framebuffer, framebuffer_offset_y, rendered_area_y);
        render_mandelbrot(framebuffer+(RES_X*lines_rendered), colorscheme, cam, 0, bottom_buffered ? RES_Y : lines_rendered, RES_X, y_offset);
        break;
      case BUTTON_RIGHT:
        cam_shift(&cam, STEP_SIZE, 0);
        render_mandelbrot(columnbuffer, colorscheme, cam, RES_X - x_offset, top_line, x_offset, RES_Y/2);
        for(uint16_t y = 0; y < RES_Y/2; y++) {
          memmove(framebuffer + (RES_X * y), framebuffer + (RES_X * y) + x_offset, (RES_X - x_offset) * sizeof(*framebuffer));
          memmove(framebuffer + (RES_X * y) + (RES_X - x_offset), columnbuffer + (x_offset * y), x_offset * sizeof(*framebuffer));
        }
        break;
      case BUTTON_LEFT:
        cam_shift(&cam, -STEP_SIZE, 0);
        render_mandelbrot(columnbuffer, colorscheme, cam, 0, top_line, x_offset, RES_Y/2);
        for(uint16_t y = 0; y < RES_Y/2; y++) {
          memmove(framebuffer + (RES_X * y) + x_offset, framebuffer + (RES_X * y), (RES_X - x_offset) * sizeof(*framebuffer));
          memmove(framebuffer + (RES_X * y), columnbuffer + (x_offset * y), x_offset * sizeof(*framebuffer));
        }
        break;
      case BUTTON_A:
        cam_zoom(&cam, ZOOM_SIZE);
        render_mandelbrot(framebuffer, colorscheme, cam, 0, top_line, RES_X, RES_Y/2);
        break;
      case BUTTON_B:
        cam_zoom(&cam, -ZOOM_SIZE);
        render_mandelbrot(framebuffer, colorscheme, cam, 0, top_line, RES_X, RES_Y/2);
        break;
      default:
        render_mandelbrot(framebuffer, colorscheme, cam, 0, top_line, RES_X, RES_Y/2);
    }
   ST7735_DrawImage(0, top_line, RES_X, (RES_Y/2), framebuffer);

   bottom_buffered = !bottom_buffered;
   top_line = bottom_buffered ? (RES_Y/2) : 0; 
   render_mandelbrot(framebuffer, colorscheme, cam, 0, top_line, RES_X, RES_Y/2);
   ST7735_DrawImage(0, top_line, RES_X, (RES_Y/2), framebuffer);
  }
  benchmark_stop();


  /**
  render_mandelbrot(framebuffer, colorscheme, cam, false, key_pressed);
  ST7735_DrawImage(0, 0, ST7735_WIDTH, (ST7735_HEIGHT / 2), framebuffer);
  render_mandelbrot(framebuffer, colorscheme, cam, true, key_pressed);
  ST7735_DrawImage(0, (ST7735_HEIGHT / 2), ST7735_WIDTH, (ST7735_HEIGHT / 2), framebuffer);
  **/
//  ST7735_DrawImage(0, 0, ST7735_WIDTH - 1, ST7735_HEIGHT - 1, (uint16_t *)0x80000000);
}
